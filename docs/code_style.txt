/*****************************************************************************
 **** 缩略词说明
 *****************************************************************************/

全大/小写：单词全部大/小写，单词间以下划线分隔。

大小写：单词首字母大小，余下部分小写（针对普通单词）或大写（适用于HTTP之类的缩略词，但不强制），单词间不用下划线分隔。




/*****************************************************************************
 **** 概要
 *****************************************************************************/

本项目代码风格的规定以尽量简化、便于记忆、易读为准则，以便于开发人员将主要精力集中于代码逻辑，故将规则定义如下：

（1）除宏和常量（语义上的常量，不一定是指语法上带const的变量）一般用全大写形式之外，其余条目一般采用全小写形式；

（2）以下划线开头的变量和函数仅供模块内部使用，不作为公开接口；

（3）注释：推荐使用英文注释（防止某些环境显示不出中文的问题），内容应尽量简明扼要（一来阅读量小，二来若少量注释就能
解释代码含义，往往说明代码较简单易懂，否则应考虑重构）且避免出现多份相同的注释；

（4）其余规则见具体条款，且本文档所有规则均是针对一般的情况，实际运用时可有所变通，但所有规则均要保证够好的可读性
（包括代码含义易于理解、排版便于阅读等）。




/*****************************************************************************
 **** 具体条款
 *****************************************************************************/

类名：全小写。

结构体和联合体（或共同体，即union）：全小写。

命名空间（namespace）：全小写。

变量：全小写，若是类私有成员变量还要加上“m_”前缀，全局变量则加“g_”前缀，静态变量则加“s_”前缀。

常量：推荐用全大写，也可用加上k前缀的大小写形式（Google的风格）。

宏：一般为全大写，但对于要（语意上）伪装成函数的宏，则拼写规则跟随该函数的拼写规则。反过来，对于要伪装成宏的函数，
	则应该用全大写。

枚举：枚举名用带enum_前缀的全小写形式，枚举成员值则用全大写（没有enum_前缀）。

typedef类型：全小写。

函数：全小写。

缩进：4个空格，或者1个tab且将编辑器的tab宽度设为4个空格。其余情况视具体排版而定。

换行：大括号建议单独一行。其余情况视排版而定。

列数：推荐为120列以内，列宽度为半角输入法状态下一个英文字母的宽度。

注释：
	（1）多行注释一般针对代码块，在代码块前面；单行注释一般针对单行代码，在行的上方或行尾。
		注意注释和代码之间的空隙以增强可读性。

	（2）针对类或函数的功能说明注释，一般只在头文件列出，源文件不再重复。因为重复的注释会使维护的工作量加倍，
		而且使用者只能看到头文件，开发者则能同时看到头文件注释和源文件的代码（即能直接看到代码逻辑），
		所以开发者只需确保代码可读性较好以及头文件注释准确，即可让自己和使用者都受益。
		对于虚函数的注释，除非子类的虚函数有特殊行为需要附加说明，否则一般没有注释，而在其基类对应的虚函数。

	（3）注释除了有解释说明的作用，还可以发挥提示的作用。例如虚函数在头文件的声明要带上virtual，但在实现
		文件里却不能带，此时可将virtual用“/**/”包围起来，即可消除语法错误，又能让人一眼即可看出该函数
		是个虚函数。

返回返回值：无特殊说明的情况下，整型返回值成功时返回0,失败时返回负值，该负值的意义可在ca_return_code.h查询
	或用相应函数来进行解析；指针型返回值成功时返回合法指针，失败时返回空指针。




/*****************************************************************************
 **** 例外
 *****************************************************************************/

1、第三方代码不必也不可能遵守以上规则。

2、较早期的原生代码，如果未进行重构，或者已经被外部大范围引用，也不会遵守以上规则，但会被标记为deprecated，
	且会增加与之相对应且符合规则的新接口。

3、对于伪装类（例如出于移植方便的需要，设置若干个伪装STL容器的类，如string、vector等）或伪装函数的命名，
	可遵循被伪装对象的规则。

